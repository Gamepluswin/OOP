#include <iostream>
 
class X 
{
public:
    X(){}
    X(int){} // int 类型可以被隐式转换成 X
    friend bool operator<(const X& x1, const X& x2) { return true; } // 只是测试，无意义
};
 
class Y 
{
public:
    Y(){}
    Y(int){} // int 类型可以被隐式转换成 Y
    bool operator<(const Y& y) const { return true; } // 只是测试，无意义
};
 
int main()
{
    X x;
    if(1 < x) // 合法，使用友元重载函数，1 可以被隐式地转换为 X 类型 －－友元函数的第一个参数
    {}
 
    Y y;
    if(1 < y) // 不合法，使用成员重载函数，函数的第一个参数是 const *this，1 不能被隐式转换
    {}
 
    return 0;
}
// 注：编译的时候可以通过注释掉不同的代码来查看错误（即合法性），后面解释不能作为友元全局重载的原因
/*
1：对于赋值操作符(=)－－比较特别，因为任何类如果不提供显示的拷贝赋值(即重载＝)，则编译器会隐式地提供一个。这样的话，如果你再通过友元声明，进行全局的定义会造成调用二义性（即使允许，编译也会出错）。

2：对于所有楼主提到的操作符(=,[],(),->)，只能声明为成员函数是为了避免不合法的书写通过编译（这是推测出的原因，更深层的可能要研究 C++ 的设计了）。这涉及到 C++ 中类型的隐式转换。
https://bbs.csdn.net/topics/390159264
*/
